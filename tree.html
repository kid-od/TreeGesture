<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Gesture Xmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }

        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1);
            opacity: 0.5;
            z-index: 10;
            border: 2px solid gold;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 20px;
            pointer-events: none;
            text-align: center;
            text-shadow: 0 0 10px #FFD700;
        }

        /* å·¦ä¸Šè§’ UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            top: 18px;
            left: 18px;
            padding: 12px 14px;
            background: rgba(10, 10, 15, 0.85);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            color: #e5e7eb;
            font-size: 12px;
            z-index: 20;
            backdrop-filter: blur(10px);
        }
        #ui-panel h2 {
            margin: 0 0 6px 0;
            font-size: 13px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: #facc15;
        }
        #ui-panel input[type="file"] {
            font-size: 11px;
            margin-top: 4px;
            color: #e5e7eb;
        }
        #ui-panel .hint {
            margin-top: 6px;
            font-size: 11px;
            color: #9ca3af;
            line-height: 1.4;
        }

        /* ä¸­å¤®ç…§ç‰‡é¢„è§ˆ + é®ç½© */
        #preview-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(4px);
            z-index: 29;
        }
        #preview-backdrop.hidden { display: none; }

        #photo-preview {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(10, 10, 18, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.7);
            color: #e5e7eb;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(16px);
            z-index: 30;
        }
        #photo-preview.hidden { display: none; }
        #photo-preview img {
            max-width: 280px;
            max-height: 220px;
            border-radius: 10px;
            object-fit: cover;
            box-shadow: 0 12px 30px rgba(0,0,0,0.8);
            background: #111827;
        }
        #photo-preview .info {
            font-size: 12px;
            max-width: 260px;
        }
        #photo-preview button {
            margin-top: 8px;
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            background: transparent;
            color: #9ca3af;
            cursor: pointer;
        }
        #photo-preview button:hover {
            background: rgba(31, 41, 55, 0.95);
            color: #e5e7eb;
        }
    </style>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨æ±‡èšé‡‘è‰²èƒ½é‡... âœ¨<br><span style="font-size:14px">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</span></div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

    <!-- å·¦ä¸Šè§’ UI -->
    <div id="ui-panel">
        <h2>GESTURE XMAS TREE</h2>
        <div>ä¸Šä¼ æ‹ç«‹å¾—ç…§ç‰‡ï¼ˆæœ€å¤š 10 å¼ ï¼‰ï¼š</div>
        <input id="photo-input" type="file" accept="image/*" multiple>
        <div class="hint">
            æ‰‹åŠ¿è¯´æ˜ï¼š<br>
            Â· âœŠ æ¡æ‹³ï¼šç¯å…‰ & ç…§ç‰‡èšæ‹¢æˆæ ‘<br>
            Â· ğŸ– å¼ å¼€æ‰‹æŒï¼šç¯å…‰ & ç…§ç‰‡æ•£å¼€<br>
            Â· ğŸ¤ æåˆï¼šéšæœºæŒ‘é€‰ä¸€å¼ ç…§ç‰‡æ”¾åœ¨å±å¹•ä¸­å¤®<br>
            Â· æ¾å¼€æ‰‹æŒ‡ï¼šç…§ç‰‡å›å½’æ ‘ä¸Šçš„ç¼©ç•¥å›¾ï¼Œä»…ä¿ç•™ç¼©ç•¥å›¾ä¸é«˜äº®
        </div>
    </div>

    <!-- ä¸­å¤®é¢„è§ˆé®ç½© + æ¡† -->
    <div id="preview-backdrop" class="hidden"></div>
    <div id="photo-preview" class="hidden">
        <img id="preview-img" src="" alt="Selected Photo">
        <div class="info">
            <div style="font-weight:600;margin-bottom:4px;">å½“å‰é€‰ä¸­ç…§ç‰‡</div>
            <div style="font-size:11px;color:#9ca3af;">æåˆéšæœºæŒ‘é€‰ï¼Œæ¾å¼€æ‰‹æŒ‡å…³é—­é¢„è§ˆï¼Œç…§ç‰‡å›åˆ°æ ‘ä¸Šçš„æ‹ç«‹å¾—ç¼©ç•¥å›¾ã€‚</div>
            <button id="preview-close">å…³é—­</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= é…ç½® =================
        const PARTICLE_COUNT = 5200;
        const TREE_HEIGHT = 60;
        const TREE_RADIUS = 22;
        const PARTICLE_SIZE = 0.8;
        const MAX_PHOTOS = 10;

        // å¯å†™æ­»æœ¬åœ°å›¾ç‰‡è·¯å¾„ï¼ˆç›¸å¯¹ index.htmlï¼‰
        const PRESET_IMAGE_URLS = [
          // 'assets/photo1.jpg',
          // 'assets/photo2.png'
        ];

        let scene, camera, renderer, composer;
        let particles = [];
        let particleSystem;
        let textureLoader;

        let isScattered = false;
        let scatterLerp = 0;

        let cameraAngle = 0;
        let cameraAngularVelocity = 0;
        const CAMERA_RADIUS = 78;
        const CAMERA_HEIGHT = 26;
        let lastHandX = null;

        let treeMesh, starMesh, bgMesh;
        const garlands = [];

        const photoGroups = [];
        const photoBasePositions = [];
        const photoScatterPositions = [];
        let selectedPhotoIndex = -1;
        let isPreviewOpen = false;

        const previewOverlay = document.getElementById('photo-preview');
        const previewBackdrop = document.getElementById('preview-backdrop');
        const previewImg = document.getElementById('preview-img');
        const previewClose = document.getElementById('preview-close');

        function closePreview() {
            previewOverlay.classList.add('hidden');
            previewBackdrop.classList.add('hidden');
            isPreviewOpen = false;
        }
        previewClose.addEventListener('click', closePreview);
        previewBackdrop.addEventListener('click', closePreview);
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePreview(); });

        // ================= Three åœºæ™¯ =================
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(Math.sin(cameraAngle) * CAMERA_RADIUS, CAMERA_HEIGHT, Math.cos(cameraAngle) * CAMERA_RADIUS);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            textureLoader = new THREE.TextureLoader();

            const ambient = new THREE.AmbientLight(0xffffff, 0.35);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xfff1d0, 1.0);
            dirLight.position.set(40, 80, 30);
            scene.add(dirLight);

            createBackgroundDome();
            createTreeBody();
            createGarlands();
            createPresents();
            createParticleSystem();
            createTopStar();
            initPhotoSlots();
            loadPresetImages();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.4,
                0.55,
                0.03
            );
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // èƒŒæ™¯ç©¹é¡¶ï¼šæ·±è“+æ˜Ÿç‚¹+ä¸€äº›æŸ”è½¯çš„â€œå…‰æ–‘â€
        function createBackgroundDome() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const grad = ctx.createRadialGradient(
                size * 0.5, size * 0.65, size * 0.15,
                size * 0.5, size * 0.65, size * 0.9
            );
            grad.addColorStop(0, '#111827');
            grad.addColorStop(0.4, '#020617');
            grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);

            // æ˜Ÿç‚¹
            ctx.fillStyle = 'rgba(255,255,255,0.65)';
            for (let i = 0; i < 34; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size * 0.4;
                const r = Math.random() * 1.4 + 0.5;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // å‡ ä¸ªæ¨¡ç³Šå…‰æ–‘ï¼ˆç±»ä¼¼ bokehï¼‰
            for (let i = 0; i < 8; i++) {
                const cx = Math.random() * size;
                const cy = Math.random() * size * 0.6;
                const rMax = 90 + Math.random() * 80;
                const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, rMax);
                const color = Math.random() < 0.5 ? '255, 255, 255' : '252, 211, 77';
                g2.addColorStop(0, `rgba(${color},0.18)`);
                g2.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g2;
                ctx.beginPath();
                ctx.arc(cx, cy, rMax, 0, Math.PI * 2);
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.encoding = THREE.sRGBEncoding;
            tex.needsUpdate = true;

            const geo = new THREE.SphereGeometry(350, 32, 32);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.BackSide });
            bgMesh = new THREE.Mesh(geo, mat);
            scene.add(bgMesh);
        }

        // æ ‘ä½“ + åœ°æ¯¯
        function createTreeBody() {
            const geo = new THREE.ConeGeometry(TREE_RADIUS * 0.98, TREE_HEIGHT * 1.05, 42, 12, false);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x0f3b20,
                roughness: 0.82,
                metalness: 0.12,
                emissive: new THREE.Color(0x02180b),
                emissiveIntensity: 0.3
            });
            treeMesh = new THREE.Mesh(geo, mat);
            treeMesh.position.y = 0;
            scene.add(treeMesh);

            const floorGeo = new THREE.CircleGeometry(TREE_RADIUS * 2.4, 64);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x101827,
                roughness: 0.96,
                metalness: 0.0
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -TREE_HEIGHT / 2 - 1.2;
            scene.add(floor);
        }

        // é‡‘è‰²ç¯å½¢å½©å¸¦
        function createGarlands() {
            const mat = new THREE.MeshBasicMaterial({ color: 0xfacc15, toneMapped: false });
            const levels = 4;
            for (let i = 0; i < levels; i++) {
                const t = i / (levels - 1);
                const yNorm = 0.15 + 0.7 * (1 - t);
                const y = yNorm * TREE_HEIGHT - TREE_HEIGHT / 2;
                const radius = TREE_RADIUS * Math.pow(1 - (yNorm - 0.15), 0.75) * 1.05;

                const geo = new THREE.TorusGeometry(radius, 0.18, 8, 80);
                const torus = new THREE.Mesh(geo, mat);
                torus.rotation.x = Math.PI / 2;
                torus.position.y = y;
                garlands.push(torus);
                scene.add(torus);
            }
        }

        // ç¤¼ç‰©ç›’
        function createPresents() {
            const colors = [0xd97757, 0x2563eb, 0xfbbf24, 0x10b981, 0x9333ea];
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const baseY = -TREE_HEIGHT / 2 - 0.8;

            for (let i = 0; i < 18; i++) {
                const sx = 1.4 + Math.random() * 1.4;
                const sy = 0.8 + Math.random() * 1.8;
                const sz = 1.4 + Math.random() * 1.4;

                const color = colors[i % colors.length];
                const mat = new THREE.MeshStandardMaterial({
                    color,
                    roughness: 0.55,
                    metalness: 0.35,
                    emissive: new THREE.Color(0x111111),
                    emissiveIntensity: 0.3
                });

                const mesh = new THREE.Mesh(boxGeo, mat);
                mesh.scale.set(sx, sy, sz);

                const r = TREE_RADIUS * 0.9 + Math.random() * 6;
                const angle = Math.random() * Math.PI * 2;
                mesh.position.set(
                    Math.cos(angle) * r,
                    baseY + sy * 0.5,
                    Math.sin(angle) * r
                );
                mesh.rotation.y = Math.random() * Math.PI * 2;

                scene.add(mesh);
            }
        }

        // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
        function createTopStar() {
            const geo = new THREE.IcosahedronGeometry(3.2, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xfffbe0, toneMapped: false });
            starMesh = new THREE.Mesh(geo, mat);
            starMesh.position.set(0, TREE_HEIGHT / 2 + 5, 0);
            scene.add(starMesh);
        }

        // ç²’å­çº¹ç†ï¼ˆæŸ”å’Œé«˜å…‰ç‚¹ï¼‰
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.35, 'rgba(255, 255, 255, 0.9)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        // åœ£è¯é…è‰²ç²’å­ï¼ˆçº¢/ç»¿/é‡‘/æš–ç™½ï¼‰
        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            particles = [];

            const palette = [
                new THREE.Color(0xfacc15), // é‡‘
                new THREE.Color(0xf97373), // çº¢
                new THREE.Color(0x22c55e), // ç»¿
                new THREE.Color(0xfef9c3), // æš–ç™½
                new THREE.Color(0xbfdbfe)  // å†·ä¸€ç‚¹çš„è“ç™½
            ];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ratio = i / PARTICLE_COUNT;
                const treePos = calculateTreeLightPosition(ratio);
                const scatterPos = calculateScatterPosition();

                positions.push(treePos.x, treePos.y, treePos.z);

                const baseColor = palette[Math.floor(Math.random() * palette.length)].clone();
                const hsl = {};
                baseColor.getHSL(hsl);
                hsl.l = THREE.MathUtils.clamp(hsl.l + (Math.random() - 0.5) * 0.12, 0.45, 0.95);
                baseColor.setHSL(hsl.h, hsl.s, hsl.l);

                colors.push(baseColor.r, baseColor.g, baseColor.b);

                particles.push({
                    treePos,
                    scatterPos,
                    currentPos: treePos.clone(),
                    velocity: new THREE.Vector3(),
                    phase: Math.random() * Math.PI * 2
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: createParticleTexture(),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9,
                vertexColors: true
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // ç¯ä¸²åˆ†å¸ƒï¼šç´§è´´æ ‘ä½“
        function calculateTreeLightPosition(ratio) {
            const t = ratio;
            const yNorm = Math.pow(t, 0.8);
            const y = (yNorm * TREE_HEIGHT) - TREE_HEIGHT / 2 + THREE.MathUtils.randFloatSpread(0.6);

            const baseR = TREE_RADIUS * Math.pow(1 - yNorm, 0.7);
            const shellBias = 0.82;
            const r = baseR * (shellBias + (1 - shellBias) * Math.random());

            const swirlTurns = 9;
            const swirl = yNorm * Math.PI * 2 * swirlTurns;
            const angle = swirl + Math.random() * 0.4;

            const jitterR = 0.35;
            const x = Math.cos(angle) * r + THREE.MathUtils.randFloatSpread(jitterR);
            const z = Math.sin(angle) * r + THREE.MathUtils.randFloatSpread(jitterR);

            return new THREE.Vector3(x, y, z);
        }

        // æ•£å¼€èŒƒå›´ï¼šçƒå£³ï¼Œå¢å¼º 3D æ„Ÿ
        function calculateScatterPosition() {
            const r = 35 + Math.random() * 35; // 35~70
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        // æ‹ç«‹å¾—å ä½è´´å›¾
        function createPlaceholderTexture(text = 'Photo') {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#6b7280';
            ctx.font = 'bold 40px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const tex = new THREE.CanvasTexture(canvas);
            tex.encoding = THREE.sRGBEncoding;
            tex.needsUpdate = true;
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            tex.magFilter = THREE.LinearFilter;
            return tex;
        }

        function createPolaroid(texture, srcUrl) {
            const group = new THREE.Group();

            const frameW = 4.8;
            const frameH = 5.6;
            const imgW = 4.0;
            const imgH = 4.0;

            const frameGeo = new THREE.PlaneGeometry(frameW, frameH);
            const frameMat = new THREE.MeshBasicMaterial({
                color: 0x4b5563,      // æ·±ç°ï¼Œä¸å‘å…‰
                side: THREE.DoubleSide,
                toneMapped: false
            });
            const frameMesh = new THREE.Mesh(frameGeo, frameMat);
            group.add(frameMesh);

            const imgGeo = new THREE.PlaneGeometry(imgW, imgH);
            const imgMat = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                toneMapped: false
            });
            const imgMesh = new THREE.Mesh(imgGeo, imgMat);
            imgMesh.position.set(0, 0.5, 0.02);
            group.add(imgMesh);

            group.userData = {
                frameMesh,
                imgMesh,
                src: srcUrl || null
            };

            return group;
        }

        // åœ¨æ ‘ä¸Šå¸ƒç½®æ‹ç«‹å¾—æŒ‚ç‚¹
        function initPhotoSlots() {
            const placeholderTex = createPlaceholderTexture();

            for (let i = 0; i < MAX_PHOTOS; i++) {
                const group = createPolaroid(placeholderTex, null);

                const t = Math.random() * 0.9 + 0.05;
                const y = t * TREE_HEIGHT - TREE_HEIGHT / 2;
                const radius = TREE_RADIUS * Math.pow(1 - t, 0.7) * 1.3;
                const angle = Math.random() * Math.PI * 2;

                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                group.position.set(x, y, z);
                group.lookAt(0, y - 1, 0);
                group.rotation.z = THREE.MathUtils.degToRad(THREE.MathUtils.randFloatSpread(10));

                scene.add(group);
                photoGroups.push(group);

                const base = new THREE.Vector3(x, y, z);

                const R = 36 + Math.random() * 18;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const sx = R * Math.sin(phi) * Math.cos(theta);
                const sy = R * Math.sin(phi) * Math.sin(theta);
                const sz = R * Math.cos(phi);
                const scatter = new THREE.Vector3(sx, sy, sz);

                photoBasePositions.push(base);
                photoScatterPositions.push(scatter);
            }
        }

        function highlightPhoto(index) {
            photoGroups.forEach((pg, i) => {
                const frame = pg.userData.frameMesh;
                if (!frame) return;
                frame.material.color.set(i === index ? 0xfbbf24 : 0x4b5563);
            });
        }

        function getActivePhotoIndices() {
            const active = [];
            photoGroups.forEach((pg, i) => {
                if (pg.userData.src) active.push(i);
            });
            return active;
        }

        function showPhotoPreview(index) {
            if (index < 0 || index >= photoGroups.length) return;
            const pg = photoGroups[index];
            const src = pg.userData.src;
            if (!src) {
                closePreview();
                return;
            }
            previewImg.src = src;
            previewOverlay.classList.remove('hidden');
            previewBackdrop.classList.remove('hidden');
            isPreviewOpen = true;
        }

        // æåˆï¼šéšæœºæŒ‘é€‰ä¸€å¼ ç…§ç‰‡å¹¶æ”¾å¤§æ˜¾ç¤º
        function pickRandomPhotoAndPreview() {
            const active = getActivePhotoIndices();
            if (!active.length) return;

            const idx = active[Math.floor(Math.random() * active.length)];
            selectedPhotoIndex = idx;
            highlightPhoto(selectedPhotoIndex);
            showPhotoPreview(selectedPhotoIndex);
        }

        // æš´éœ²ä¸€ä¸ªå‡½æ•°ï¼Œæ–¹ä¾¿ä½ åœ¨ä»£ç æˆ–æ§åˆ¶å°é‡Œæ‰‹åŠ¨æŒ‚æœ¬åœ°å›¾ç‰‡
        window.addLocalPhoto = function(url) {
            if (!textureLoader) return;
            textureLoader.load(
                url,
                (tex) => {
                    tex.encoding = THREE.sRGBEncoding;
                    tex.minFilter = THREE.LinearMipMapLinearFilter;
                    tex.magFilter = THREE.LinearFilter;
                    tex.needsUpdate = true;

                    let idx = -1;
                    for (let i = 0; i < photoGroups.length; i++) {
                        if (!photoGroups[i].userData.src) {
                            idx = i;
                            break;
                        }
                    }
                    if (idx === -1) {
                        console.warn('ç…§ç‰‡æŒ‚ç‚¹å·²æ»¡ï¼ˆæœ€å¤š 10 å¼ ï¼‰ã€‚');
                        return;
                    }

                    const pg = photoGroups[idx];
                    pg.userData.imgMesh.material.map = tex;
                    pg.userData.imgMesh.material.needsUpdate = true;
                    pg.userData.src = url;
                },
                undefined,
                (err) => {
                    console.error('åŠ è½½å›¾ç‰‡å¤±è´¥ï¼š', url, err);
                }
            );
        };

        // é¢„åŠ è½½å†™æ­»çš„å›¾ç‰‡
        function loadPresetImages() {
            PRESET_IMAGE_URLS.forEach((url) => {
                window.addLocalPhoto(url);
            });
        }

        // çŠ¶æ€åˆ‡æ¢ï¼šèšæ‹¢ / æ•£å¼€ï¼ˆåŒæ—¶å…³é—­å¤§å›¾é¢„è§ˆï¼‰
        function transformShape(targetState) {
            isScattered = targetState;
            if (isPreviewOpen) {
                closePreview();
            }
        }

        function updateParticlesAndPhotos() {
            const target = isScattered ? 1 : 0;
            scatterLerp += (target - scatterLerp) * 0.05;

            const positions = particleSystem.geometry.attributes.position.array;
            const damping = 0.95;
            const baseForce = 0.06;
            const scatterForce = 0.028;
            const forceStrength = THREE.MathUtils.lerp(baseForce, scatterForce, scatterLerp);

            const time = performance.now() * 0.001;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particles[i];
                let targetPos = scatterLerp > 0.5 ? p.scatterPos.clone() : p.treePos.clone();

                // æ•£å¼€æ—¶è½»å¾®æ¼‚æµ® + è½¨é“æ—‹è½¬ï¼Œå¢å¼º 3D æ„Ÿ
                if (scatterLerp > 0.5) {
                    const dir = targetPos.clone().normalize();
                    const wobble = Math.sin(time * 0.8 + p.phase) * 1.2;
                    targetPos.add(dir.multiplyScalar(wobble));

                    const angle = time * 0.12 + p.phase * 0.3;
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);
                    const x = targetPos.x * cosA - targetPos.z * sinA;
                    const z = targetPos.x * sinA + targetPos.z * cosA;
                    targetPos.x = x;
                    targetPos.z = z;
                }

                const force = targetPos.sub(p.currentPos).multiplyScalar(forceStrength);
                p.velocity.add(force);
                p.velocity.multiplyScalar(damping);
                p.currentPos.add(p.velocity);

                positions[i * 3] = p.currentPos.x;
                positions[i * 3 + 1] = p.currentPos.y;
                positions[i * 3 + 2] = p.currentPos.z;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.rotation.y += 0.001;

            photoGroups.forEach((pg, i) => {
                const base = photoBasePositions[i];
                const scatter = photoScatterPositions[i];
                pg.position.lerpVectors(base, scatter, scatterLerp);
                pg.lookAt(camera.position);
            });

            if (starMesh) starMesh.rotation.y += 0.01;
            garlands.forEach(g => g.rotation.z = Math.sin(time * 0.15) * 0.03);
        }

        // MediaPipe æ‰‹åŠ¿ï¼šæ¡æ‹³ / å¼ å¼€ / æåˆ
        let pinchPreviouslyDetected = false;

        const PINCH_DISTANCE_THRESHOLD = 0.04;   // æåˆåˆ¤æ–­è·ç¦»

        function initMediaPipe() {
            const videoElement = document.getElementById('video-input');
            const hands = new window.Hands({
                locateFile: (file) =>
                    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onHandsResults);

            const cam = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 320,
                height: 240
            });

            cam.start()
                .then(() => { document.getElementById('loading').style.display = 'none'; })
                .catch((err) => {
                    console.error('Camera start error:', err);
                    document.getElementById('loading').innerText = 'æ— æ³•å¯åŠ¨æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™';
                });
        }

        function onHandsResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                lastHandX = null;
                pinchPreviouslyDetected = false;
                return;
            }
            const landmarks = results.multiHandLandmarks[0];

            // å¼ å¼€ / æ¡æ‹³ï¼šæ§åˆ¶æ•£å¼€/èšæ‹¢
            const wrist = landmarks[0];
            const tipsIdx = [8, 12, 16, 20];
            let avgDist = 0;
            tipsIdx.forEach((idx) => {
                const tip = landmarks[idx];
                const dx = tip.x - wrist.x;
                const dy = tip.y - wrist.y;
                avgDist += Math.sqrt(dx * dx + dy * dy);
            });
            avgDist /= tipsIdx.length;

            if (avgDist > 0.35)       transformShape(true);   // å¼ å¼€ -> æ•£å¼€
            else if (avgDist < 0.25)  transformShape(false);  // æ¡æ‹³ -> èšæ‹¢

            // æ‰‹æŒå·¦å³ â†’ ç›¸æœºæ—‹è½¬
            const palm = landmarks[9];
            const palmX = palm.x;
            if (lastHandX !== null) {
                const deltaX = palmX - lastHandX;
                cameraAngularVelocity -= deltaX * 0.5;
            }
            lastHandX = palmX;

            // æåˆï¼ˆæ‹‡æŒ‡ + é£ŸæŒ‡ï¼‰
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const dx = thumbTip.x - indexTip.x;
            const dy = thumbTip.y - indexTip.y;
            const pinchDist = Math.sqrt(dx * dx + dy * dy);
            const pinchDetected = pinchDist < PINCH_DISTANCE_THRESHOLD;

            if (pinchDetected && !pinchPreviouslyDetected) {
                // æåˆå¼€å§‹ï¼šéšæœºæŒ‘é€‰å¹¶æ”¾å¤§ä¸€å¼ ç…§ç‰‡
                pickRandomPhotoAndPreview();
            } else if (!pinchDetected && pinchPreviouslyDetected) {
                // æåˆç»“æŸï¼šå…³é—­é¢„è§ˆï¼Œç…§ç‰‡å›å½’ç¼©ç•¥å›¾
                if (isPreviewOpen) {
                    closePreview();
                }
            }
            pinchPreviouslyDetected = pinchDetected;
        }

        // ä¸Šä¼ å›¾ç‰‡ -> ç”¨ addLocalPhoto æŒ‚åˆ°æ ‘ä¸Šï¼ˆæœ€å¤š 10 å¼ ï¼‰
        const photoInput = document.getElementById('photo-input');
        photoInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files || []);
            if (!files.length) return;
            files.slice(0, MAX_PHOTOS).forEach((file) => {
                const url = URL.createObjectURL(file);
                window.addLocalPhoto(url);
            });
            photoInput.value = '';
        });

        // æ¸²æŸ“å¾ªç¯
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateParticlesAndPhotos();

            cameraAngularVelocity *= 0.9;
            cameraAngle += cameraAngularVelocity;
            camera.position.set(
                Math.sin(cameraAngle) * CAMERA_RADIUS,
                CAMERA_HEIGHT,
                Math.cos(cameraAngle) * CAMERA_RADIUS
            );
            camera.lookAt(0, 5, 0);

            composer.render();
        }

        // å¯åŠ¨
        initThree();
        initMediaPipe();
    </script>
</body>
</html>
